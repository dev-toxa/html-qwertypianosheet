<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.16"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
        }

        #track-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #track {
            position: absolute;
            left: 50px;
            font-size:5px;
            /* playhead 위치와 맞춤 */
            top: 0;
            height: 100%;
            will-change: transform;
        }

        .note {
            position: absolute;
        }
    </style>
</head>

<body>
    <div id="controls">
        <input type="file" id="midi-upload" accept=".mid,.midi">
    </div>
    <div id="track-container">
        <div id="track"></div>
    </div>
    <script>
        const PIXELS_PER_SECOND = 100; // 1초당 가로 길이 (박자 간격 조절)
        const NOTE_HEIGHT = 20;        // 음높이 간격
        const midiMap = {
            "C1": "1",
            "C#1": "!",
            "D1": "2",
            "D#1": "@",
            "E1": "3",
            "F1": "4",
            "F#1": "$",
            "G1": "5",
            "G#1": "%",
            "A1": "6",
            "A#1": "^",
            "B1": "7",
            "C2": "8",
            "C#2": "*",
            "D2": "9",
            "D#2": "(",
            "E2": "0",
            "F2": "q",
            "F#2": "Q",
            "G2": "w",
            "G#2": "W",
            "A2": "e",
            "A#2": "E",
            "B2": "r",
            "C3": "t",
            "C#3": "T",
            "D3": "y",
            "D#3": "Y",
            "E3": "u",
            "F3": "i",
            "F#3": "I",
            "G3": "o",
            "G#3": "O",
            "A3": "p",
            "A#3": "P",
            "B3": "a",
            "C4": "s",
            "C#4": "S",
            "D4": "d",
            "D#4": "D",
            "E4": "f",
            "F4": "g",
            "F#4": "G",
            "G4": "h",
            "G#4": "H",
            "A4": "j",
            "A#4": "J",
            "B4": "k",
            "C5": "l",
            "C#5": "L",
            "D5": "z",
            "D#5": "Z",
            "E5": "x",
            "F5": "c",
            "F#5": "C",
            "G5": "v",
            "G#5": "V",
            "A5": "b",
            "A#5": "B",
            "B5": "n",
            "C6": "m",
            "C#6": "M",
        }
        const lines = [
            "1!2@34$5%6^78*90", // 1행
            "qQwWeErRtTyYuUiIoOpP", // 2행
            "asSdDfGgHhJjklL",    // 3행
            "zZxCcVvBbNmM"        // 4행
        ];
        const keyLineMap = {};
        lines.forEach((chars, index) => {
            const lineNum = index + 1; // 행 번호 (1, 2, 3, 4)
            for (const char of chars) {
                keyLineMap[char] = lineNum;
            }
        });
        console.log(keyLineMap);
        document.getElementById('midi-upload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const arrayBuffer = await file.arrayBuffer();
            const midi = new Midi(arrayBuffer);

            renderMidi(midi);
            // setupPlayback(midi);
        });
        function renderMidi(midi) {
            const track = document.getElementById('track');
            track.innerHTML = "";

            // 1. 모든 노트를 하나의 배열로 합치고 시간순으로 정렬
            let allNotes = [];
            midi.tracks.forEach(t => {
                t.notes.forEach(note => {
                    const char = midiMap[note.name];
                    if (char) { // 매핑된 글자가 있는 경우만
                        allNotes.push({
                            time: note.time,
                            name: note.name,
                            char: char
                        });
                    }
                });
            });
            allNotes.sort((a, b) => a.time - b.time);

            // 2. 동시 입력 노트 처리 (같은 시간대 노트들 간격 벌리기)
            const OFFSET_STEP = 20; // 동시 노트를 옆으로 밀어낼 픽셀 값
            let timeGroups = {};

            allNotes.forEach(note => {
                // 소수점 셋째 자리까지 반올림하여 그룹화 (미세한 시간차 무시)
                const timeKey = Math.round(note.time * 1000) / 1000;

                if (!timeGroups[timeKey]) {
                    timeGroups[timeKey] = 0;
                }

                const div = document.createElement('div');
                div.className = `note`;
                div.innerText = note.char;

                // 기본 위치 (초당 픽셀) + (동시 발생 순서 * 오프셋)
                const horizontalPos = (note.time * PIXELS_PER_SECOND) + (timeGroups[timeKey] * OFFSET_STEP);

                div.style.left = `${horizontalPos}px`;
                div.style.top = `${keyLineMap[note.char] * NOTE_HEIGHT}px`;

                track.appendChild(div);

                // 해당 시간대의 노트 카운트 증가
                timeGroups[timeKey]++;
            });
        }
    </script>
</body>

</html>