<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Sequential Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.16"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow-x: auto;
            overflow-y: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.15);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        #track-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #track {
            position: absolute;
            left: 20px;
            top: 0;
            height: 100%;
            display: flex;
            align-items: flex-start;
            padding-top: 50px;
        }

        /* 화음을 감싸는 사각형 */
        .chord-group {
            position: absolute;
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 4px 8px;
            border: 1.5px solid #00f2ff;
            background: rgba(0, 242, 255, 0.1);
            border-radius: 6px;
            white-space: nowrap;
            box-shadow: 0 0 8px rgba(0, 242, 255, 0.2);
        }

        .note-char {
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
    </style>
</head>

<body>
    <div id="controls">
        <input type="file" id="midi-upload" accept=".mid,.midi">
    </div>
    <div id="track-container">
        <div id="track"></div>
    </div>

    <script>
        // 설정 값
        const NOTE_HEIGHT = 80;    // 행 간격
        const MIN_GAP = 15;        // 그룹 간 최소 간격 (픽셀)
        const PIXELS_PER_SECOND = 100; // 시간 차이에 따른 추가 간격 가중치

        const midiMap = {
            "C1": "1", "C#1": "!", "D1": "2", "D#1": "@", "E1": "3", "F1": "4", "F#1": "$", "G1": "5", "G#1": "%", "A1": "6", "A#1": "^", "B1": "7",
            "C2": "8", "C#2": "*", "D2": "9", "D#2": "(", "E2": "0", "F2": "q", "F#2": "Q", "G2": "w", "G#2": "W", "A2": "e", "A#2": "E", "B2": "r",
            "C3": "t", "C#3": "T", "D3": "y", "D#3": "Y", "E3": "u", "F3": "i", "F#3": "I", "G3": "o", "G#3": "O", "A3": "p", "A#3": "P", "B3": "a",
            "C4": "s", "C#4": "S", "D4": "d", "D#4": "D", "E4": "f", "F4": "g", "F#4": "G", "G4": "h", "G#4": "H", "A4": "j", "A#4": "J", "B4": "k",
            "C5": "l", "C#5": "L", "D5": "z", "D#5": "Z", "E5": "x", "F5": "c", "F#5": "C", "G5": "v", "G#5": "V", "A5": "b", "A#5": "B", "B5": "n",
            "C6": "m", "C#6": "M"
        };

        const lines = ["1!2@34$5%6^78*90", "qQwWeErRtTyYuUiIoOpP", "asSdDfGgHhJjklL", "zZxCcVvBbNmM"];
        const keyLineMap = {};
        lines.forEach((chars, index) => {
            for (const char of chars) keyLineMap[char] = index + 1;
        });

        document.getElementById('midi-upload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const arrayBuffer = await file.arrayBuffer();
            const midi = new Midi(arrayBuffer);
            renderMidi(midi);
        });

        function renderMidi(midi) {
            const track = document.getElementById('track');
            track.innerHTML = "";

            // 1. 데이터 수집 및 시간순 정렬
            let allNotes = [];
            midi.tracks.forEach(t => {
                t.notes.forEach(note => {
                    const char = midiMap[note.name];
                    if (char) allNotes.push({ time: note.time, char, midi: note.midi });
                });
            });

            // 2. 시간대별 그룹화
            const groups = {};
            allNotes.forEach(note => {
                const timeKey = Math.round(note.time * 1000) / 1000;
                if (!groups[timeKey]) groups[timeKey] = [];
                groups[timeKey].push(note);
            });

            const sortedTimes = Object.keys(groups).sort((a, b) => a - b);
            
            // 3. 순차적 배치 (절대 겹치지 않게 가로 위치 계산)
            let currentX = 0; 
            let lastTime = 0;

            sortedTimes.forEach((timeKey, index) => {
                const chordNotes = groups[timeKey];
                chordNotes.sort((a, b) => a.midi - b.midi);

                const groupDiv = document.createElement('div');
                groupDiv.className = 'chord-group';

                // 폰트 크기 조절 로직
                const count = chordNotes.length;
                const fontSize = count > 3 ? Math.max(12, 20 - count) : 18;
                const gap = count > 3 ? Math.max(4, 12 - count) : 10;
                groupDiv.style.gap = `${gap}px`;

                // 노트들 추가
                chordNotes.forEach(note => {
                    const span = document.createElement('span');
                    span.className = 'note-char';
                    span.innerText = note.char;
                    span.style.fontSize = `${fontSize}px`;
                    groupDiv.appendChild(span);
                });

                // 화면에 미리 추가해서 너비를 측정
                track.appendChild(groupDiv);
                const groupWidth = groupDiv.offsetWidth;

                // --- 위치 계산 로직 ---
                // 이전 노트와의 실제 시간 차이 계산
                const timeDiff = parseFloat(timeKey) - lastTime;
                // 이전 그룹의 끝 지점 + (시간 차이에 따른 여백) + 최소 간격
                const spacing = Math.max(MIN_GAP, timeDiff * PIXELS_PER_SECOND);
                
                groupDiv.style.left = `${currentX + spacing}px`;
                
                const firstChar = chordNotes[0].char;
                groupDiv.style.top = `${(keyLineMap[firstChar] || 1) * NOTE_HEIGHT}px`;

                // 다음 배치를 위해 현재 그룹의 끝 지점 업데이트
                currentX += spacing + groupWidth;
                lastTime = parseFloat(timeKey);
            });
        }
    </script>
</body>

</html>